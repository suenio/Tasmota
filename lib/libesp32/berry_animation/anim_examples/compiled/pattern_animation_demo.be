# Generated Berry code from Animation DSL
# Source: pattern_animation_demo.anim
# Generated automatically
# 
# This file was automatically generated by compile_all_dsl_examples.sh
# Do not edit manually - changes will be overwritten

# Original DSL source:
# # Unified Pattern-Animation Demo
# # This DSL example demonstrates the new unified architecture where Animation extends Pattern
# 
# strip length 30
# 
# # UNIFIED ARCHITECTURE: solid() returns Animation (which IS a Pattern)
# # No more artificial distinction between patterns and animations
# animation solid_red = solid(red)      # Animation: solid red (infinite duration)
# animation solid_blue = solid(blue)    # Animation: solid blue (infinite duration)
# animation solid_green = solid(green)  # Animation: solid green (infinite duration)
# 
# # COMPOSITION: Animations can use other animations as base
# animation pulsing_red = pulse(solid_red, 0%, 100%, 2s)     # Animation using animation
# animation pulsing_blue = pulse(solid_blue, 50%, 100%, 1s)  # Animation using animation
# animation pulsing_green = pulse(solid_green, 20%, 80%, 3s) # Animation using animation
# 
# # Set priorities (all animations inherit from Pattern)
# solid_red.priority = 0        # Base animation priority
# pulsing_red.priority = 10     # Higher priority
# pulsing_blue.priority = 20    # Even higher priority
# pulsing_green.priority = 5    # Medium priority
# 
# # Set opacity (all animations inherit from Pattern)
# solid_red.opacity = 255       # Full opacity
# pulsing_red.opacity = 200     # Slightly dimmed
# pulsing_blue.opacity = 150    # More dimmed
# 
# # RECURSIVE COMPOSITION: Animations can use other animations!
# # This creates infinitely composable effects
# animation complex_pulse = pulse(pulsing_red, 30%, 70%, 4s)  # Pulse a pulsing animation!
# 
# # Create a sequence that demonstrates the unified architecture
# sequence unified_demo {
#   # All animations can be used directly in sequences
#   play solid_red for 2s       # Use solid animation
#   wait 500ms
#   
#   # Composed animations work seamlessly
#   play pulsing_red for 3s     # Use pulse animation
#   wait 500ms
#   
#   play pulsing_blue for 2s    # Use another pulse animation
#   wait 500ms
#   
#   # Show recursive composition - animation using animation
#   play complex_pulse for 4s   # Nested animation effect
#   wait 500ms
#   
#   # Show that all animations support the same properties
#   repeat 2 times:
#     play solid_green for 1s   # Animation with priority/opacity
#     play pulsing_green for 2s # Animation with priority/opacity
#     wait 500ms
# }
# 
# # Run the demonstration
# run unified_demo

import animation

# Unified Pattern-Animation Demo
# This DSL example demonstrates the new unified architecture where Animation extends Pattern
var strip = global.Leds(30)
var engine = animation.create_engine(strip)
# UNIFIED ARCHITECTURE: solid() returns Animation (which IS a Pattern)
# No more artificial distinction between patterns and animations
var solid_red_ = animation.solid(0xFFFF0000)  # Animation: solid red (infinite duration)
var solid_blue_ = animation.solid(0xFF0000FF)  # Animation: solid blue (infinite duration)
var solid_green_ = animation.solid(0xFF008000)  # Animation: solid green (infinite duration)
# COMPOSITION: Animations can use other animations as base
var pulsing_red_ = animation.pulse(animation.global('solid_red_', 'solid_red'), 0, 255, 2000)  # Animation using animation
var pulsing_blue_ = animation.pulse(animation.global('solid_blue_', 'solid_blue'), 127, 255, 1000)  # Animation using animation
var pulsing_green_ = animation.pulse(animation.global('solid_green_', 'solid_green'), 51, 204, 3000)  # Animation using animation
# Set priorities (all animations inherit from Pattern)
animation.global('solid_red_').priority = 0  # Base animation priority
animation.global('pulsing_red_').priority = 10  # Higher priority
animation.global('pulsing_blue_').priority = 20  # Even higher priority
animation.global('pulsing_green_').priority = 5  # Medium priority
# Set opacity (all animations inherit from Pattern)
animation.global('solid_red_').opacity = 255  # Full opacity
animation.global('pulsing_red_').opacity = 200  # Slightly dimmed
animation.global('pulsing_blue_').opacity = 150  # More dimmed
# RECURSIVE COMPOSITION: Animations can use other animations!
# This creates infinitely composable effects
var complex_pulse_ = animation.pulse(animation.global('pulsing_red_', 'pulsing_red'), 76, 178, 4000)  # Pulse a pulsing animation!
# Create a sequence that demonstrates the unified architecture
def sequence_unified_demo()
  var steps = []
  # All animations can be used directly in sequences
  steps.push(animation.create_play_step(animation.global('solid_red_'), 2000))  # Use solid animation
  steps.push(animation.create_wait_step(500))
  # Composed animations work seamlessly
  steps.push(animation.create_play_step(animation.global('pulsing_red_'), 3000))  # Use pulse animation
  steps.push(animation.create_wait_step(500))
  steps.push(animation.create_play_step(animation.global('pulsing_blue_'), 2000))  # Use another pulse animation
  steps.push(animation.create_wait_step(500))
  # Show recursive composition - animation using animation
  steps.push(animation.create_play_step(animation.global('complex_pulse_'), 4000))  # Nested animation effect
  steps.push(animation.create_wait_step(500))
  # Show that all animations support the same properties
  for repeat_i : 0..2-1
    steps.push(animation.create_play_step(animation.global('solid_green_'), 1000))  # Animation with priority/opacity
    steps.push(animation.create_play_step(animation.global('pulsing_green_'), 2000))  # Animation with priority/opacity
    steps.push(animation.create_wait_step(500))
  end
  var seq_manager = animation.SequenceManager(engine)
  seq_manager.start_sequence(steps)
  return seq_manager
end
# Run the demonstration
# Start all animations/sequences
if global.contains('sequence_unified_demo')
  var seq_manager = global.sequence_unified_demo()
  engine.add_sequence_manager(seq_manager)
else
  engine.add_animation(animation.global('unified_demo_'))
end
engine.start()
